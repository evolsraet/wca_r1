# 📋 게시판 필터 시스템 사용법

## 🎯 개요
게시판의 필터 시스템이 자동화되어 blade 파일에서만 필터를 추가하면 JavaScript에서 자동으로 처리됩니다.

## 🔧 필터 구조

### 1. Where 절 필터 (`filters.where.xxx`)
- API의 `where` 파라미터로 전달되는 필터들
- `articles.컬럼명:값` 형태로 자동 변환됩니다

### 2. 일반 필터 (`filters.xxx`)
- 검색어, 페이지네이션 등 일반적인 필터들

```javascript
filters: {
    // where 절용 필터들 (blade에서 추가 가능)
    where: {
        category: '',      // articles.category:값
        status: '',        // articles.status:값
        user_type: ''      // articles.user_type:값
    },
    // 일반 필터들
    search_text: '',
    page: 1,
    paginate: 10
}
```

## 📝 Blade에서 필터 추가하는 방법

### 1. 새로운 where 절 필터 추가

**1단계**: `articleList.js`의 `filters.where` 객체에 기본값 추가
```javascript
filters: {
    where: {
        category: '',
        status: '',        // 새로 추가
        priority: ''       // 새로 추가
    },
    // ... 기존 코드
}
```

**2단계**: Blade 파일에 필터 폼 요소 추가
```blade
<!-- 상태 필터 추가 예시 -->
<div class="col-md-3">
    <x-forms.select
        name="status"
        model="filters.where.status"
        :options="['active' => '활성', 'inactive' => '비활성']"
        placeholder="전체 상태"
        @change="onWhereFilterChange()"
        no-margin
        :errors="null"
    />
</div>

<!-- 우선순위 필터 추가 예시 -->
<div class="col-md-3">
    <x-forms.select
        name="priority"
        model="filters.where.priority"
        :options="['high' => '높음', 'normal' => '보통', 'low' => '낮음']"
        placeholder="전체 우선순위"
        @change="onWhereFilterChange()"
        no-margin
        :errors="null"
    />
</div>
```

### 2. 검색 입력필드 추가
```blade
<div class="col-md-4">
    <input type="text"
           x-model="filters.where.author_name"
           @keyup.enter="onWhereFilterChange()"
           class="form-control"
           placeholder="작성자명으로 검색">
</div>
```

## 🔄 자동화된 기능들

### 1. API where 절 자동 생성 (함수형 스타일)
```javascript
// 예시: filters.where = { category: '공지사항', status: 'active' }
// 결과: where=articles.category:공지사항,articles.status:active
buildWhereClause() {
    return Object.entries(this.filters.where)
        .filter(([key, value]) => value && value.toString().trim() !== '')
        .map(([key, value]) => `articles.${key}:${value}`)
        .join(',');
}
```

### 2. URL 파라미터 자동 파싱 (타입 안전)
```javascript
// 안전한 URL 파라미터 파싱 (숫자 자동 변환 + 타입 체크)
parseUrlParam(urlParams, key, defaultValue = '') {
    const value = urlParams.get(key);
    if (value === null || value === undefined) return defaultValue;
    
    // 빈 문자열 체크
    const trimmedValue = value.trim();
    if (trimmedValue === '') return defaultValue;
    
    // 숫자 변환 시도
    const numValue = Number(trimmedValue);
    return !isNaN(numValue) ? numValue : trimmedValue;
}
```

### 3. URL 업데이트 조건 확인 (타입 안전)
```javascript
// 기본값과 다를 경우에만 URL에 포함 (null 안전)
shouldIncludeInUrl(key, value) {
    // null, undefined 체크
    if (value == null) return false;
    
    const defaultConditions = {
        page: value > 1,
        paginate: value !== 10,
        search_text: value && typeof value === 'string' && value.trim() !== ''
    };
    
    // 기본 조건이 있으면 사용, 없으면 일반적인 빈 값 체크
    if (key in defaultConditions) {
        return defaultConditions[key];
    }
    
    // 일반적인 값 체크 - 안전한 문자열 변환
    const stringValue = String(value).trim();
    return stringValue !== '';
}
```

### 4. API where 절 자동 생성 (API 스펙 준수)
```javascript
// API 스펙에 맞는 where 절 생성 (조건들을 '|'로 구분)
buildWhereClause() {
    const whereClauses = [];
    
    Object.entries(this.filters.where).forEach(([key, value]) => {
        if (value == null) return;
        
        const stringValue = String(value).trim();
        if (stringValue === '') return;
        
        // _null 값 처리 (null 비교)
        if (stringValue === '_null') {
            whereClauses.push(`articles.${key}:_null`);
            return;
        }
        
        // 비교 연산자 포함된 값 처리
        // 예: ">:10", "<:5", "like:검색어", "whereIn:1,2,3"
        if (stringValue.includes(':') && this.isOperatorValue(stringValue)) {
            whereClauses.push(`articles.${key}:${stringValue}`);
        } else {
            // 단순 등호 비교
            whereClauses.push(`articles.${key}:${stringValue}`);
        }
    });
    
    // '|'로 구분하여 반환 (API 스펙)
    return whereClauses.join('|');
}
```

### 5. Where 절 헬퍼 메소드들
```javascript
// 편의 메소드들로 복잡한 조건 쉽게 설정
addWhereLike(key, value)           // LIKE 검색
addWhereIn(key, values)            // IN 조건
addWhereGreaterThan(key, value)    // > 비교
addWhereLessThan(key, value)       // < 비교  
addWhereNull(key)                  // NULL 체크
```

## 📋 사용 예시

### 기본 카테고리 필터 (기존)
```blade
<x-forms.select
    name="category"
    model="filters.where.category"
    :options="collect(json_decode($board->categories))->mapWithKeys(fn($cat) => [$cat => $cat])->toArray()"
    placeholder="전체 카테고리"
    @change="onWhereFilterChange()"
    no-margin
    :errors="null"
/>
```

### 새로운 필터 추가 예시
```blade
<!-- 상태 필터 -->
<x-forms.select
    name="status"
    model="filters.where.status"
    :options="['published' => '게시됨', 'draft' => '임시저장', 'archived' => '보관됨']"
    placeholder="전체 상태"
    @change="onWhereFilterChange()"
    no-margin
    :errors="null"
/>

<!-- 작성자 타입 필터 -->
<x-forms.select
    name="author_type"
    model="filters.where.author_type"
    :options="['admin' => '관리자', 'user' => '일반사용자', 'guest' => '게스트']"
    placeholder="전체 작성자"
    @change="onWhereFilterChange()"
    no-margin
    :errors="null"
/>

<!-- 날짜 범위 필터 -->
<input type="date"
       x-model="filters.where.created_from"
       @change="onWhereFilterChange()"
       class="form-control">
```

## 🔍 고급 Where 절 사용법

### 1. 기본 등호 비교
```blade
<!-- 카테고리 필터 (기본) -->
<x-forms.select
    name="category"
    model="filters.where.category"
    :options="['notice' => '공지사항', 'faq' => 'FAQ']"
    placeholder="전체 카테고리"
    @change="onWhereFilterChange()"
/>
```
생성되는 where 절: `articles.category:notice`

### 2. LIKE 검색
```blade
<!-- 제목 LIKE 검색 -->
<input type="text"
       x-model="filters.where.title"
       @input="filters.where.title = 'like:' + $event.target.value"
       @change="onWhereFilterChange()"
       placeholder="제목 검색">
```
생성되는 where 절: `articles.title:like:검색어`

### 3. 숫자 범위 검색 (수정된 방법)
```blade
<!-- 조회수 최소값 (올바른 방법) -->
<input type="number"
       x-model="tempHitMin"
       @input="
           delete filters.where.hit_min;
           filters.where.hit = $event.target.value ? '>:' + $event.target.value : '';
           onWhereFilterChange();
       "
       placeholder="최소 조회수">

<!-- 조회수 최대값 -->
<input type="number"
       x-model="tempHitMax"  
       @input="
           delete filters.where.hit_max;
           filters.where.hit_upper = $event.target.value ? '<:' + $event.target.value : '';
           onWhereFilterChange();
       "
       placeholder="최대 조회수">
```
생성되는 where 절: `articles.hit:>:100|articles.hit_upper:<:1000`

**권장하는 방법 (헬퍼 메소드 사용):**
```blade
<!-- 조회수 범위 검색 (깔끔한 방법) -->
<div x-data="{ hitMin: '', hitMax: '' }">
    <input type="number"
           x-model="hitMin"
           @change="setWhereMin('hit', hitMin)"
           placeholder="최소 조회수">
           
    <input type="number"
           x-model="hitMax"
           @change="setWhereMax('hit', hitMax)"
           placeholder="최대 조회수">
</div>

<!-- 또는 범위를 한번에 설정 -->
<div x-data="{ hitMin: '', hitMax: '' }">
    <input type="number" x-model="hitMin" placeholder="최소 조회수">
    <input type="number" x-model="hitMax" placeholder="최대 조회수">
    <button @click="setWhereRange('hit', hitMin, hitMax)">
        범위 검색
    </button>
</div>
```
생성되는 where 절: `articles.hit:>=:100|articles.hit:<=:1000`

### 4. NULL 체크
```blade
<!-- 카테고리가 없는 글 찾기 -->
<button @click="filters.where.category = '_null'; onWhereFilterChange()"
        class="btn btn-outline-secondary">
    카테고리 없는 글
</button>
```
생성되는 where 절: `articles.category:_null`

### 5. IN 조건 (여러 값 중 하나)
```blade
<!-- 여러 사용자 ID 중 선택 -->
<x-forms.select
    name="user_ids"
    model="filters.where.user_id"
    :options="$users"
    multiple
    @change="filters.where.user_id = 'whereIn:' + Array.from($event.target.selectedOptions).map(o => o.value).join(','); onWhereFilterChange()"
/>
```
생성되는 where 절: `articles.user_id:whereIn:1,2,3,4`

### 6. JavaScript에서 동적 조건 설정
```javascript
// 복잡한 검색 조건 설정 예시
setupAdvancedSearch() {
    // 최근 7일 이내 글
    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    this.addWhereGreaterThan('created_at', weekAgo.toISOString().split('T')[0]);
    
    // 인기글 (조회수 100 이상)
    this.addWhereGreaterThan('hit', 100);
    
    // 특정 카테고리들만
    this.addWhereIn('category', ['notice', 'event', 'news']);
    
    // 제목에 특정 키워드 포함
    this.addWhereLike('title', '중요');
    
    this.loadArticles();
}

// 검색 초기화
resetAdvancedSearch() {
    Object.keys(this.filters.where).forEach(key => {
        this.filters.where[key] = '';
    });
    this.loadArticles();
}
```

## 🎯 API 스펙 요약

### Where 절 구문 형식
- **기본**: `articles.field:value`
- **비교**: `articles.field:operator:value`
- **NULL**: `articles.field:_null`
- **여러 조건**: `condition1|condition2|condition3`

### 지원하는 연산자
- `>`, `<`, `>=`, `<=` - 숫자/날짜 비교
- `like` - 문자열 LIKE 검색
- `whereIn` - IN 조건 (쉼표로 구분된 값들)
- `orWhere` - OR 조건
- `_null` - NULL 비교

### 예시 URL
```
?where=articles.category:notice|articles.hit:>:100|articles.created_at:>=:2024-01-01
```

이렇게 하면 "공지사항 카테고리이면서 조회수가 100 이상이고 2024년 이후 작성된 글"을 검색합니다.

## ⚡ 핵심 메소드

### 📥 데이터 로딩 관련

#### `loadFiltersFromUrl()`
- URL 파라미터에서 필터 값들을 자동으로 로드
- `this.filters` 전체를 한번에 순회하여 효율적으로 처리
- `parseUrlParam()` 유틸리티를 사용해 안전한 파싱

#### `parseUrlParam(urlParams, key, defaultValue)`
- URL 파라미터를 안전하게 파싱하는 유틸리티
- 숫자 자동 변환 기능 포함

#### `getDefaultFilterValue(key)`
- 각 필터의 기본값을 반환하는 유틸리티

### 🔗 API 관련

#### `buildApiParams()`
- API 호출에 필요한 모든 파라미터를 구성
- where 절, 검색어, 정렬 파라미터 등을 통합 관리

#### `buildWhereClause()`
- `filters.where` 객체를 API where 파라미터로 변환
- 함수형 프로그래밍 스타일로 간결하게 구현

### 🌐 URL 관련

#### `updateUrl()`
- 현재 필터 상태를 URL에 자동 반영
- `shouldIncludeInUrl()` 유틸리티로 조건부 포함

#### `shouldIncludeInUrl(key, value)`
- 해당 파라미터가 URL에 포함되어야 하는지 판단
- 기본값과 다른 경우에만 포함

### 🎛️ 이벤트 핸들러

#### `onWhereFilterChange()`
- where 절 필터가 변경될 때 호출
- 자동으로 1페이지로 이동 후 목록 재로드

### 🔍 범위 검색 관련

#### `setWhereRange(baseKey, minValue, maxValue)`
- 범위 검색을 한번에 설정 (중복 조건 자동 정리)
- 기존 관련 조건들을 자동으로 삭제 후 새로 설정

#### `setWhereMin(key, value)` / `setWhereMax(key, value)`
- 단일 범위 조건 설정
- 기존 중복 조건 자동 제거

#### `setWhereConditions(conditions)`
- 여러 조건을 한번에 설정
- 빈 값은 자동으로 삭제

## 🎉 리팩토링으로 얻은 장점

### 1. **코드 가독성 향상**
- 함수형 프로그래밍 스타일 적용
- 메소드 분리로 단일 책임 원칙 준수

### 2. **재사용성 증가**
- `parseUrlParam()`, `shouldIncludeInUrl()` 등 유틸리티 함수
- 다른 컴포넌트에서도 활용 가능

### 3. **유지보수성 개선**
- 중복 코드 제거
- 로직 분리로 버그 수정 용이

### 4. **타입 안정성**
- URL 파라미터 파싱 시 자동 타입 변환
- null 체크 및 기본값 처리

## 🔍 디버깅 팁

콘솔에서 현재 필터 상태 확인:
```javascript
// Alpine DevTools 또는 브라우저 콘솔에서
$data.filters.where          // where 절 필터들
$data.filters               // 전체 필터 상태
$data.buildWhereClause()    // 생성된 where 절 확인
$data.buildApiParams()      // API 파라미터 확인
``` 

```javascript
// 통합된 필터 로딩 방식
loadFiltersFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);

    // this.filters 전체를 한번에 순회하여 처리
    Object.entries(this.filters).forEach(([key, value]) => {
        if (key === 'where') {
            // where 절 필터들 처리
            Object.keys(value).forEach(whereKey => {
                this.filters.where[whereKey] = this.parseUrlParam(urlParams, whereKey, '');
            });
        } else {
            // 일반 필터들 처리
            this.filters[key] = this.parseUrlParam(urlParams, key, this.getDefaultFilterValue(key));
        }
    });
}
``` 
